# Unit1-Internet-and-IP

## 互联网和IP简介（The Internet and IP Introduction）

欢迎来到第一单元，这是你将学习大局以及一些细节的单元，你将学习互联网如何工作的基础知识，你甚至可以弄清楚我们中的哪个是Phil，哪个是Nick。我们希望帮助你理解为什么互联网是像现在这样设计的，它的一些优点和缺点，我们还将教你一些普遍接受的网络设计原则，例如**分层(layering)，封装(encapsulation)和分组交换(packet switching)**。

在本单元结束时，你应该能够回答诸如”什么是互联网？ 什么是互联网地址？“以及”万维网，Skype和Bit Torrent等应用”如何工作等问题，这些原则将帮助你在未来设计更好的网络。

在第一单元结束时，你应该熟悉称为四层模型的互联网，它描述了互联网如何分解为四个不同的层，你将了解这些层是什么，以及为什么它们是良好网络设计的基本原则：

![](../.gitbook/Unit1-Internet-and-IP/1.jpg)

你将了解互联网的四层是什么，以及它们如何协同工作，你将了解大多数应用程序使用称为**传输控制协议**或**TCP**的传输层以及某些应用程序如何使用该协议。你还将了解到互联网的工作原理是将数据分解成称为**分组(packet) **的小单元，例如，当你请求网页时，你的计算机向Web服务器发送一些分组，互联网决定这些数据分组如何到达正确的目的地。

本单元还详细研究了一个称为网络层的层。你可能听说过**IP，互联网协议**，它是以互联网命名的协议，因为它是让整个网络工作的粘合剂；你可以更改所有其他层，但是要使用互联网，你需要在网络层使用互联网协议。

你将了解互联网协议的作用以及它是如何做到的，你将了解**互联网协议地址(IP Address)**以及它们是如何分配的，你将了解互联网如何根据其互联网地址来决定分组应采用的路径。

最后，我们将向您展示一些软件工具，您可以使用这些工具检查计算机如何使用互联网。因此，你可以在下次浏览网页时将本单元所学的知识应用到其中！



## 应用程序生命中的一天（A day in the life of an application）

最终让网络变得有趣的是使用它们的应用程序，互联网设计的主要贡献者之一大卫克拉克（Dave Clark）曾经写道，“当前网络的指数增长似乎表明，**连通性**本身就是一种回报，它比邮件或万维网等任何个人应用程序都更有价值。”**连通性**是指世界不同地区的两台计算机可以相互连接并交换数据。如果你将计算机连接到互联网，你就突然可以与互联网上连接的所有其他计算机通话，至少可以和那些想和你谈谈的人通话。让我们看看这到底意味着什么，以及一些现代应用程序——万维网、Skype和BitTorrent——是如何使用它的。

网络应用程序的巨大威力在于，你可以拥有多台计算机，每台计算机都有自己的私有数据，每台计算机可能由不同的人拥有和控制，它们可以交换信息。本地应用程序只能访问驻留在本地系统上的数据，与此不同，网络应用程序可以在全球范围内交换数据。例如，考虑使用web浏览器阅读杂志。出版商运行的服务器包含所有杂志文章，也可能包含过去发行的所有文章。随着文章的更正或添加，你可以立即看到更新的版本和内容。整个后台文章目录可能太多，你无法下载，因此你可以按需加载它们。如果你没有网络，那么你需要有人给你发一张最新版本的DVD或U盘。

所以基本模型是，你有两台计算机，每台计算机在本地运行一个程序，这两个程序通过网络进行通信。最常用的通信模型是**双向、可靠的字节流**。运行在计算机A上的程序A可以写入数据，然后通过网络传输，这样运行在计算机B上的程序B就可以读取数据。类似地，程序B可以写入程序A可以读取的数据。还有其他通信模式，我们将在本课程后面讨论，但可靠的双向字节流是目前最常见的一种。

![1/3]()

让我们看看这是什么样子。右边的计算机B正在等待其他计算机连接到它。例如，它可能是一个web服务器。左边的计算机A想要与B通信。这个例子中，它（A）是一部运行web浏览器的手机。A和B建立了一个连接。现在，当A向连接写入数据时，它通过网络传输，B可以读取数据。类似地，如果B向连接写入数据，则该数据通过网络传输，A可以读取该数据。任何一方都可以关闭连接。例如，当web浏览器完成从web服务器请求数据时，它可以关闭连接。同样，如果服务器愿意，它也可以关闭连接。如果你曾经在web浏览器中看到一条错误消息，上面写着“由对等方重置连接”（“connection reset by peer”），这就是它的意思：web服务器在web浏览器不希望连接时关闭了连接。当然，服务器也可以拒绝连接：你可能会看到连接被拒绝的消息，或者让浏览器等待很长时间，因为服务器没有拒绝响应。

![1/4]()

现在我们已经了解了网络应用程序通信的基本方式，让我们看一下我们的第一个示例：万维网（world wide web）。万维网使用一种叫做HTTP的东西工作，HTTP代表超文本传输协议。当你在浏览器中看到http://时，这意味着它正在使用http进行通信。我们将在本课程后面介绍应用程序时更深入地了解HTTP的细节。现在，我将给出一个非常高层次的概述。

在HTTP中，客户端打开与服务器的连接并向其发送命令。最常见的命令是GET，它请求一个页面。HTTP被设计成以文档为中心的程序通信方式。例如，如果在我的浏览器中键入http://www.stanford.edu/ ，浏览器打开与服务器www.stanford.edu的连接，并发送站点根页面的GET请求。服务器接收请求，检查请求是否有效，用户是否可以访问该页面，并发送响应。响应有一个与之关联的数字代码。例如，如果服务器向GET发送200 OK响应，这意味着请求已被接受，响应的其余部分包含文档数据。在www.stanford.edu网页的示例中，200 OK响应将包括描述斯坦福主页的超文本。还有其他类型的请求，如PUT、DELETE和INFO，以及其他响应，如400错误请求。

因为HTTP是以文档为中心的，所以客户端请求为文件命名。HTTP都是ASCII文本：它是人类可读的。例如，Stanford的GET请求的开头如下所示：GET/HTTP/1.1。对成功请求的响应的开始如下所示：HTTP/1.1 200 OK。

但基本模型很简单：客户端通过向连接写入请求来发送请求，服务器读取请求，对其进行处理，并向连接写入响应，然后客户端读取响应。

![1/5]()

让我们看看第二个应用程序BitTorrent。BitTorrent是一个允许人们共享和交换大型文件的程序。与客户端从服务器请求文档的web不同，在BitTorrent中，客户端从其他客户端请求文档。BitTorrent将文件分解成称为片段的数据块，这样单个客户端就可以并行地请求其他多个客户端。当一个客户端从另一个客户端下载一个完整的片段时，它会告诉其他客户端它有这个片段，这样他们也可以下载它。这些协作客户端的集合称为群集（swarms）。所以我们谈论客户端加入或离开swarm。

BitTorrent使用与万维网完全相同的机制：可靠的双向数据流。但它使用它的方式稍微复杂一些。当客户端想要下载一个文件时，它首先必须找到一个叫做torrent文件的东西。通常，你可以通过万维网找到它，然后通过HTTP下载。此torrent文件描述了有关要下载的数据文件的一些信息。它还告诉BitTorrent谁是该torrent的跟踪器。跟踪器是一个节点，它跟踪（因此得名）哪些客户端是swarm的成员。要加入torrent，你的客户端再次通过HTTP与跟踪器联系，以请求其他客户端的列表。你的客户端打开与其中一些客户端的连接，并开始请求文件片段。反过来，这些（被连接的）客户端同样可以请求片段。此外，当一个新客户端加入swarm时，它（追踪器）可能会告诉这个新客户端连接到你的客户端。因此，客户端和服务器之间的连接不是单一的，而是客户端和服务器之间的密集连接图，动态地交换数据。

![1/6]()

对于我们的第三个也是最后一个应用程序，让我们看看Skype，一种流行的语音、聊天和视频服务。Skype是一个专有系统，它没有任何关于其内部工作方式的官方文档。2008年，哥伦比亚大学（Columbia）的一些研究人员主要通过查看Skype客户端在何时何地发送消息来了解它的工作原理。不过，这些消息是加密的，所以它们无法查看内部。然而，2011年，Efim Bushmanov对该协议进行了反向工程，并发布了开源代码，现在我们对协议的工作原理有了更好的了解。

在最简单的模式下，当你想在Skype上呼叫某人时，它是一个简单的客户端-服务器交换，有点像HTTP。你，即呼叫方，打开与收件人的连接；如果对方接听你的电话，你将开始交换语音、视频或聊天数据。

在某些方面，这看起来像万维网的例子：一方打开与另一方的连接，然后交换数据。但与web不同，web有一个客户端和一个服务器，在Skype的情况下，你有两个客户端。因此，与其让个人计算机从专用服务器请求某些内容，不如让两台个人计算机相互请求数据。这种差异对Skype的工作方式有很大的影响。

![1/7]()

这种复杂性来自一种称为**NAT**或**网络地址转换器（Network Address Translato）**的东西。今天到处都是NAT：小型家庭无线路由器是NAT；当手机连接到互联网时，它就在NAT的后面。

我们将在本课程后面更详细地介绍它们，但现在你需要知道的是，如果你在NAT后面，那么你可以打开到Internet的连接，但是Internet上的其他节点无法轻松打开到你的连接。在本例中，这意味着客户端B可以自由地打开到其他节点的连接，但其他节点很难打开连接。这就是这个红绿色梯度所显示的：来自绿色端的连接可以正常工作，但来自红色端的连接不行。

因此，这里的复杂之处在于，如果客户机A想要呼叫客户机B，它就无法打开连接。Skype必须解决这个问题。

![1/8]()

它使用一种叫做**集合服务器（rendezvous server）**的东西来实现。当你登录Skype时，你的客户端将打开与控制服务器网络的连接。在这种情况下，客户端B打开到集合服务器的连接。这很好，因为服务器不在NAT后面，客户端B可以毫无问题地打开连接。

当客户端A调用客户端B时，它会向集合服务器发送一条消息。由于服务器与客户端B有一个打开的连接，它告诉B有来自A的呼叫请求。呼叫对话框会在客户端B上弹出。如果客户端B接受呼叫，则会打开与客户端A的连接。客户端A试图打开与客户端B的连接，但由于B在NAT后面，因此无法打开。因此，它向客户端B已经连接到的计算机发送一条消息，然后请求客户端B打开与客户端A的连接。由于客户端a不在NAT后面，此连接可以正常打开。这称为**反向连接**，因为它反转了启动连接的预期方向：客户端A正试图连接到客户端B，但客户端B打开了到客户端A的连接。

这在Skype中发生，因为Skype客户端通常是个人计算机。公开访问的web服务器很少支持NAT：由于你希望Internet上的每个人都能访问服务器，因此将其置于NAT之后是一个坏主意。因此，打开与web服务器的连接很容易。然而，出于安全和其他原因，个人计算机往往在NAT之后。因此，Skype必须结合一些新的通信模式来解决这些问题。

![1/9]()

那么，如果两个客户端都支持NAT，Skype会怎么做？我们无法反向连接。客户端A无法打开到客户端B的连接，客户端B无法打开到客户端A的连接。

为了处理这种情况，Skype引入了第二种服务器，称为**中继（relay）**。中继服务器不能在NAT后面。如果客户机A和客户机B都在NAT后面，则通过中继进行通信。它们都打开了与中继服务器的连接。当客户端A发送数据时，中继服务器通过客户端B打开的连接将数据转发给客户端B。类似地，当客户机B发送数据时，中继服务器通过客户机A打开的连接将数据转发给客户机A。



总结，我们看到了网络应用程序最常见的通信模型：可靠的双向字节流。这允许在不同计算机上运行的两个程序交换数据。它将整个网络抽象为一个简单的读/写关系。

虽然这是一个非常简单的通信模型，但它可以以非常创新和复杂的方式使用。我们看了3个例子：万维网、BitTorrent和Skype。万维网是一种客户端-服务器模式：客户端打开与服务器的连接并请求文档，服务器用文档进行响应。BitTorrent是一种点对点模式，成群结队的客户端相互打开连接以交换数据片段，从而创建一个密集的连接网络。Skype是两者的混合体：当Skype客户端可以直接通信时，它们以点对点的方式进行通信；但有时客户端无法直接打开连接，因此只能通过集合服务器或中继服务器。

因此，你可以看到看起来非常简单的抽象，一个双向的、可靠的数据流，可以以许多有趣的方式使用。通过改变程序打开连接的方式以及不同程序的功能，我们可以创建复杂的应用程序，从文档检索到大量下载，再到IP电话。例如，BitTorrent中的跟踪器具有与客户端截然不同的数据和角色，正如Skype除了客户端之外还具有中继和集合服务器。

当然，互联网正在不断发展。谁知道下一个令人惊叹的新应用程序是什么？虽然它可能具有与这三种不同的通信模式，但它几乎肯定会在某些新配置中使用双向、可靠的字节流。



## 四层网络模型（The four layer Internet model）

在上一个视频中，你了解了不同的应用程序（如BitTorrent、Skype和万维网）如何使用双向可靠字节流在互联网上进行通信。

为我们的应用程序创建这种可靠的通信模型需要许多不同的部分共同工作。但是，尽管我们使用各种各样的互联网应用程序，并且以非常不同的速度发送多种数据，但应用程序发送和接收数据的方式却有惊人的相似性。例如，应用程序希望发送和接收数据，而不必担心数据在互联网上的路径或路由。而且几乎所有的应用程序都希望确信它们的数据是正确传输的，任何丢失或损坏的数据都会自动重新传输，直到正确接收为止。

早期的互联网先驱们创建了“4层互联网模型”来描述组成互联网的操作层次结构，这样应用程序就可以一次又一次地重用相同的构建块，而不必为每个应用程序从头开始创建它们。分层是网络中一个重要且常用的概念，在本课程中我们将多次看到它，甚至有一段视频专门介绍分层的概念。

让我们看看4层互联网模型的每一层都做了什么，记住所有四个层都是为了使最终主机中的应用程序能够可靠地通信。

为了解释它是如何工作的，我将从底层开始。我们将看到每一层都有不同的职责，每一层都在下面的层之上构建一个服务，一直到应用程序之间的双向可靠字节流通信。

让我们从**链路层（Link Layer）**开始。

互联网由终端主机、链路和路由器组成。数据依次在每个链路上逐跳传送，数据以分组的形式传递。一个分组由我们想要传递的数据和一个报头组成，报头告诉网络该分组将被传递到哪里，它来自哪里，等等。

链路层的工作是一次通过一条链路传输数据，你可能听说过以太网和WiFi——这是两个不同链路层的示例。

![2/8]()

对我们来说，下一层是最重要的一层：网络层。网络层的工作是通过互联网端到端地将分组从源传输到目的地。

分组是网络中重要的基本构件。分组是我们给一个自包含的数据集合起的名字，加上一个描述数据是什么、数据去哪里以及数据来自哪里的头。你经常会看到这样绘制的分组：

![补充]()

网络层分组称为数据报。它们由一些数据和一个包含“收件人”和“发件人”地址的标题组成——就像我们在信上写的“收件人”和“发件人”地址一样。

网络将数据报交给下面的链路层，告诉它通过第一条链路发送数据报。换句话说，链路层正在向网络层提供服务。基本上，链路层说：“如果你给我一个数据报来发送，我将通过一个链路为你传输。”

链路的另一端是路由器。路由器的链路层接受来自链路的数据报，并将其交给路由器中的网络层。路由器上的网络层检查数据报的目的地地址，并负责将数据报一次一跳地路由到最终目的地，它通过再次发送到链路层，并将其传送到下一个链路来实现这一点。依此类推，直到到达目的地的网络层。

注意，网络层不需要关心链路层如何通过链路发送数据报。事实上，不同的链接层以非常不同的方式工作；以太网和WiFi显然非常不同。网络层和链路层之间的这种关注点分离允许每个层专注于自己的工作，而不必担心另一层如何工作。这也意味着单个网络层有一种与许多不同链路层通信的通用方式，只需将数据报交给它们发送即可。这种关注点的分离是通过每一层的模块化和一个通用的定义良好的API实现的。

在互联网中，网络层是特殊的：当我们向互联网发送分组时，我们必须使用互联网协议。正是互联网协议（IP）将互联网连接在一起。我们将在稍后的视频中了解更多有关IP的详细信息。但就目前而言，了解一些关于IP的基本事实是件好事。

IP尽最大努力将分组传送到另一端。但它没有承诺。IP分组可能会丢失，可能会无序传输，也可能会损坏，没有任何保证。

这可能会令人惊讶。当分组不能保证被发送时，互联网怎么能工作呢？嗯，如果一个应用程序想要保证其数据在必要时将被重新传输，并且将有序地、无损坏地交付给应用程序，那么它需要在IP之上运行另一个协议，这是传输层的工作。

![2/16]()

最常见的传输层是**TCP**，或**传输控制协议**。（你可能听说过TCP/IP，即应用程序同时使用TCP和IP的情况）。

TCP确保由Internet一端的应用程序发送的数据以正确的顺序正确地传递到Internet另一端的应用程序。如果网络层丢弃了一些数据报，TCP将重新传输它们，如果需要的话会多次。如果网络层不按顺序发送数据，可能是因为两个分组沿着不同的路径到达目的地，TCP将再次将数据按正确的顺序发送。在以后的视频中，你将了解很多关于TCP及其工作原理的信息。目前，需要记住的主要事情是，TCP向应用程序提供了一个服务，以保证数据的正确有序传递，运行在网络层服务之上，该服务提供了不可靠的数据报传递服务。

我相信你可以想象，web客户端或电子邮件客户端等应用程序发现TCP确实非常有用。通过使用TCP确保数据正确传递，他们不必担心实现应用程序内部的所有机制。他们可以利用开发人员为正确实现TCP所付出的巨大努力，并重用它来正确地交付数据。重用是分层的另一大优势。

但并非所有应用程序都需要正确交付数据。例如，如果视频会议应用程序正在发送分组中的视频片段，那么等待分组被多次重传可能没有意义；最好还是继续前进。所以有些应用程序不需要TCP服务。

如果应用程序不需要可靠的交付，那么它可以使用更简单的**UDP**（或用**户数据报协议**）。UDP只是将应用程序数据捆绑起来，并将其交给网络层，以便传递到另一端。UDP不提供交付保证。

换句话说，应用程序至少可以选择两种不同的传输层服务：TCP和UDP。事实上，还有许多其他选择，但这些是最常用的传输层服务。

![1/23]()

最后，我们在4层模型的顶部有应用层。当然，有成千上万的应用程序使用互联网。虽然每个应用程序都不同，但它可以通过使用从应用程序层到下面的TCP或UDP服务的定义良好的API重用传输层。

正如我们在上一个视频中看到的，应用程序通常希望在两个端点之间有一个双向的可靠字节流。它们可以发送它们想要的任何字节流，并且应用程序有自己的协议，该协议定义了在两个端点之间流动的数据的语法和语义，例如，正如我们在上一个视频中看到的，当web客户端从web服务器请求页面时，web客户端会发送GET请求。这是超文本传输协议（http）的命令之一。http规定GET命令以ASCII字符串的形式发送，同时发送所请求页面的URL。就应用层而言，GET请求直接发送到另一端的对等方——web服务器应用程序，应用程序不需要知道它是如何到达那里的，或者需要重新传输多少次。在web客户端上，应用程序层将GET请求交给TCP层，TCP层提供确保可靠传递请求的服务，它使用网络层的服务来实现这一点，而网络层又使用链路层的服务。

我们说每一层都与其对等层进行通信，这就好像每一层只与链路或互联网另一端的同一层通信，而不考虑下面的层如何在那里获取数据。

那么，把这一切放在一起。

网络工程师发现将构成互联网的所有功能安排成层很方便。

顶部是应用程序，如BitTorrent、Skype或万维网，它与目的地的对等层进行对话。当应用程序有数据要发送时，它将数据交给传输层，传输层负责将数据可靠地（或不可靠地）传递到另一端。传输层通过将数据交给网络层，将数据发送到另一端，网络层的任务是将数据分成分组，每个分组都有正确的目标地址。最后，分组被交给链路层，链路层负责将分组沿着其路径从一个跃点传递到下一个跃点。数据从一个路由器跳到另一个路由器，网络层将它转发到下一个路由器，一次一个，直到它到达目的地。在那里，数据向上传递到各个层，直到到达应用程序。

![2/31]()

现在我们已经看到了4层是什么，我将用两件你需要知道的额外事情来结束。

![2/33]()

首先，IP通常被称为互联网的“细腰”。这是因为如果我们想使用互联网，我们必须使用互联网协议，或IP，我们别无选择。

但是对于链路层我们有很多选择：IP在许多不同的链路层上运行，例如以太网、WiFi、DSL、3G蜂窝等等。

在不可靠的IP层之上，我们可以在许多不同的传输层之间进行选择。我们已经看到了TCP和UDP。还有  用于实时数据的rtp和许多其他传输层。当然，有成千上万种不同的应用程序。

![2/35]()

你应该知道的第二件事是，在20世纪80年代，国际标准组织（ISO）创建了一个7层模型来表示任何类型的网络：它被称为7层开放系统互连或OSI模型。在本课程中，我们没有花任何时间在它上面，因为它已经被4层互联网模型所取代。如果你感兴趣的话，你可以找到任何一本网络教科书，维基百科对这7层做了详细的描述。7层模型定义了结合在4层互联网模型中的层。例如，我们今天称之为链路层的被分为链层（定义帧格式）和物理层（定义电缆上的电压水平或连接器的物理尺寸）。网络层基本相同，传输层和应用层在OSI模型中分别由两个层表示。这些是常用互联网协议的示例，以及它们如何映射到OSI编号方案。

今天，7层OSI模型的唯一真正遗产是编号系统。你经常会听到网络工程师将网络层称为“第3层”，即使它是Internet层中从底部向上的第2层。类似地，你会听到人们将以太网称为第2层协议，将应用程序称为第7层协议。



## 互联网协议模型（The IP service model）

现在，你已经了解了4层Internet模型，我们将重点介绍网络层。

这是互联网最重要的一层——事实上，对许多人来说，这就是互联网。无论何时我们使用互联网，我们都需要使用互联网协议来发送和接收分组。

你会记得，我们说每个层都为上面的层提供“服务”。为了正确使用层，我们需要很好地理解它提供的服务。

因此，在本视频中，我将介绍互联网协议提供的服务。

![3/2]()

IP数据报由一个报头和一些数据组成。当传输层有数据要发送时，它会将一个传输段交给下面的网络层。网络层将传输段放入新的IP数据报中。IP的工作是将数据报传送到另一端。但首先，IP数据报必须通过第一条链路到达第一个路由器。IP将数据报发送到链路层，链路层将数据报放入链路帧，如以太网分组，并将其发送到第一个路由器。

![3/4]()

IP服务的特点是这里列出了四个属性。它从终端主机向终端主机发送数据报；它是不可靠的，但尽最大努力提供数据报。网络不保持与数据报相关联的每个流状态。

让我们依次看看表中列出的每一项。

首先，IP是**数据报服务**。当我们要求IP为我们发送一些数据时，它会创建一个数据报并将我们的数据放入其中。数据报是根据其报头中的信息通过网络单独路由的分组。换句话说，数据报是自包含的。

报头包含目的地的IP地址，我们在这里将IP目的地地址其缩写为“IP DA”。每个路由器的转发决策基于IP DA。数据报报头还包含一个IP源地址或“IP SA”，表示分组来自何处，因此接收方知道在何处发送任何响应。数据报通过网络从一个路由器一步一步地路由到下一个路由器，从IP源地址一直路由到IP目标地址。稍后我们将进一步了解路由器的工作原理。但就目前而言，知道每个路由器都包含一个转发表就足够了，该表告诉它在哪里发送与给定目标地址匹配的分组。路由器不知道整个路径——它只是使用目的地地址索引到其转发表中，以便它可以将分组沿着路径转发到其最终目的地的下一跳。一个接一个地，一步一步地，分组只使用数据报中的目标地址从源到目的地。

你经常会听到IP数据报如何路由和邮政服务如何路由信件之间的类比。这是一个很好的比喻。在邮政服务中，我们把一封写有目的地地址的信放进信箱，然后从一个分拣办公室到另一个分拣办公室，一个一个地一个接一个地发送给我们，直到到达目的地。发送者和接收者都不知道——或不可见——邮政服务中的信件或互联网中的数据报所走的路径。IP服务模型提供了一种包括到目的地的路由服务。

第二，也许令人惊讶的是，IP不可靠。IP不保证分组将被传送到目的地。它们可能会延迟交付、无序交付或根本不交付。分组可能会在传输过程中被复制，例如被一个行为不正常的路由器复制。要记住的关键一点是，IP是不可靠的，不能提供任何保证。

但它不会因为感觉可以（丢弃）就随意丢弃数据报。如果你相信网络有感情，IP确实承诺只在必要时丢弃数据报。例如，路由器中的分组队列可能因拥塞而填满，迫使路由器丢弃下一个到达的分组。IP不会尝试重新发送数据——事实上，IP不会告诉源分组已被丢弃。类似地，错误的路由表可能会导致分组被发送到错误的目的地。或者导致分组被错误地复制。IP并没有承诺这些错误不会发生，也没有在它们发生时检测到它们。但IP确实承诺只在必要时犯这些错误。

事实上，IP数据报服务与基本邮政服务非常相似。基本邮政服务没有承诺我们的信件将按时送达，或者如果我们连续发送2-3封信件，它们将按照发送顺序接收，它也没有承诺它们将被送达（除非我们支付更昂贵的端到端服务以保证送达）。

事实上，归根结底，IP是一种极其简单、最低限度的服务。它完全不维护与通信相关的状态。我们说通信服务是“无连接的”，因为它不是通过建立与通信相关联的端到端状态开始的。换句话说，当我们进行一次持续几分钟的Skype呼叫，并且该呼叫由许多IP数据报组成时，IP层不知道该呼叫，只是单独地、独立地路由每个数据报。

你可能想知道为什么IP服务如此简单。毕竟，它是整个互联网的基础。互联网上的每一次通信都使用——**必须使用**——IP服务。考虑到互联网的重要性，让IP变得可靠不是更好吗？毕竟，我们确实说过，大多数应用程序都需要可靠的字节通信服务。

IP服务模型设计得如此简单有几个原因。

1. 使网络保持简单、愚蠢和最小化。更快、更精简、构建和维护成本更低。人们相信，如果网络保持简单，具有非常高的功能和要求，那么分组可以以非常低的成本非常快速地传送。当时的想法是，可以使用专用硬件使一个简单的网络运行得非常快。考虑到网络是由分散在网络中的大量路由器实现的，如果它们能够保持简单，那么它们可能会更可靠，维护成本更容易承受，并且需要升级的频率更低。
2. 端到端原则：尽可能在端主机中实现功能。在通信系统的设计中，有一个众所周知的原则称为**端到端原则**，即如果你能够正确地在端点实现功能，那么你应该在端点实现（该功能）。我们将在以后的视频中更深入地研究端到端原则，但基本思想是在端点放置尽可能多的智能——在我们的例子中，是源计算机和目标计算机。这可能有几个优点，例如确保为应用程序正确实现功能，如果功能在终端计算机上的软件中实现，而不是在Internet的硬件中实现，则更容易发展和改进功能。在互联网的情况下，人们决定可靠的通信和控制拥塞等功能应该在端点完成——由源计算机和目标计算机完成，而不是由网络完成。当时，这是一个相当激进的建议，也是一个与电话系统截然不同的设计选择。电话系统最初是建立在简单手机和功能丰富的复杂电话交换机网络的基础上的。在后面的视频中，我们将研究作为通信系统重要架构原则之一的端到端原则。我们将看到许多端到端原则的实例。例如，当我们研究传输层时，我们将看到终端主机如何在不可靠的IP网络服务上构建可靠的通信服务。
3. 允许在顶部构建各种可靠（或不可靠）的服务。如果IP是可靠的——换句话说，如果任何丢失的分组都被自动重新传输——那么对于某些服务来说，它将不是理想的。例如，在像视频聊天这样的实时应用程序中，可能没有必要重新传输丢失的数据，因为数据可能到达得太晚而没有用处。相反，应用程序可能会选择显示一些空白像素或使用前一帧中的像素。通过不提供任何可靠性保证，IP允许应用程序选择其所需的可靠性服务。
4. 适用于任何链路层：IP很少对链路层进行假设。IP对下面的链路层期望很低：链路可以是有线或无线的，并且不需要重新传输或拥塞控制。有人说IP非常简单，对底层链路层的假设很少，所以可以通过信鸽运行IP。事实上，甚至有一个互联网标准告诉你怎么做！让IP在任何链路层上运行是有意义的，因为互联网是专门为连接现有网络而创建的（这就是为什么它被称为互联网）。

除了基本的不可靠、尽力而为、无连接的数据报服务外，IP还提供一些其他精心选择的服务。IP的设计者们非常努力地在提供通信工作所需的最低限度的服务和一种根本不起作用的服务之间找到平衡。

我将在这里介绍五个功能，你将在以后的视频中了解其中的每一个功能，所以我将在这里不详细介绍。但我将简要介绍每一项，以便你了解完整IP服务的范围。

首先，IP试图防止分组永远循环。由于IP路由器在Internet上逐跳转发分组，路由器中的转发表可能出错，导致分组开始沿着同一路径循环。当转发表正在更改并且它们暂时进入不一致状态时，最有可能发生这种情况。IP使用一种非常简单的机制来捕获并删除似乎卡在循环中的分组，而不是试图阻止循环的发生（这将需要很大的复杂性）。为此，IP只需在每个数据报的报头中添加一个跃点计数字段。它被称为**生存时间（time to live）**，或**TTL字段**。它从一个像128这样的数字开始，然后由它通过的每个路由器递减。如果它达到零，IP断定它一定卡在一个循环中，路由器丢弃数据报。这是一种简单的机制，是典型的IP——它并不保证循环不会发生，它只是试图限制网络中无限循环分组泛滥所造成的损害。

如果分组太长，IP将对其进行分段。IP设计用于在任何类型的链路上运行。大多数链路对它们可以携带的分组的大小有限制。例如，以太网只能传输长度小于1500字节的分组。如果一个应用程序要发送的字节数超过1500字节，则在发送IP数据报之前，必须将其分成1500字节的块。现在，沿着通往目的地的路径，1500字节的数据报可能需要经过只能承载较小分组（例如1000字节）的链路。连接两条链路的路由器将把数据报分成两个较小的数据报。IP提供了一些标头字段，我们将在一分钟内看到这些字段，以帮助路由器将数据报分割成两个独立的IP数据报，同时提供终端主机重新正确组装数据所需的信息。

IP使用报头校验和来减少将数据报发送到错误目的地的机会。IP在数据报报头中包含一个校验和字段，用于尝试并确保数据报传递到正确的位置。如果分组由于路由器的错误而被意外地频繁地发送到错误的位置，这可能是一个相当大的安全问题。

目前使用的IP有两个版本：IPv4，目前有90%以上的终端主机使用IPv4。它使用你可能熟悉的32位地址。由于IPv4地址即将用完，互联网正逐步过渡到IPv6，而IPv6使用128位地址。你将在稍后的视频中了解IPv4和IPv6的详细信息。

最后，IP允许向数据报头添加新字段。这是喜忧参半。一方面，它允许在标题中添加新的功能，这些功能很重要，但不在原始标准中。另一方面，这些字段需要处理，因此需要路径上路由器的额外功能，打破了简单、愚蠢、最小转发路径的目标。实际上，路由器使用或处理的选项很少。

![3/15]()

现在，我将向你展示IPv4报头，并解释所有字段的作用。我不需要你记住所有字段的位置（我自己也不记得它们的所有位置）。但我确实希望你了解每个字段的作用，因为它有助于你了解IP服务模型的范围。它应该有助于巩固你的理解，并让你清楚地认识到IP并没有多大作用——它是一种刻意简化的服务。下面是IPv4报头的图片，这是目前使用的最常见的报头。我在这里用32位字画了它，其中“0位”是第一个发送到电线上的。

此阴影部分是IPv4标头，后面是6个数据。

IP头中最重要的字段是：

1. 目标IP地址。
2. 源IP地址。
3. 协议ID，它告诉我们数据字段中的内容。本质上，它允许目标端主机对到达的分组进行解复用，将它们发送到正确的代码以处理分组。如果协议ID的值为“6”，那么它会告诉我们分组含一个TCP段，因此我们可以安全地将数据报传递给TCP代码，它将能够正确解析该段。互联网分配号码管理局（IANA）定义了140多个不同的协议ID值，代表不同的传输协议。

版本告诉我们IP的哪个版本——目前，合法值为IPv4和IPv6。此标头是IPv4标头。我们将在稍后的视频中看到IPv6标头。

包括报头和所有数据在内的分组总长度可达64KB。

“生存时间（Time to Live）”字段帮助我们防止分组在网络中意外循环，每个路由器都需要减少TTL字段。如果它达到零，路由器应该丢弃分组。

按照这种方式，当源发送具有固定TTL值的分组时，如果它开始以循环方式传输，则保证它会被路由器破坏。

有时分组对于即将发送的链接来说太长。如果需要，包ID、标志和片段偏移都有助于路由器将IP包分割成更小的自包含包。我们将在稍后的视频中了解碎片是如何工作的。

服务类型字段向路由器提示此分组的重要性。

标题长度告诉我们标题有多大---有些标题有可选的额外字段来携带额外信息。

最后，在整个报头上计算校验和，以防报头损坏，我们不太可能错误地将分组发送到错误的目的地。



总之，IP非常重要：我们每次在Internet上发送和接收分组时都会使用它。

IP提供了一种刻意简单的服务。它是一个简单、愚蠢、最小的服务，有四个主要功能：它通过互联网逐跳发送数据报；服务不可靠且尽力而为； 没有每个流状态使协议无连接。

在这一点上，你应该对什么是IP协议、它的服务模型以及它如何适应Internet 4层层次结构感到满意。如果你有疑问，我建议你在4层模型上重新观看此视频和之前的视频。

你还可以找到许多关于IPv4工作原理的好参考资料。任何一本好的网络教科书都会花大量的篇幅来解释什么是IP，以及为什么它是这样设计的。例如，Kurose和Ross的第六版《计算机网络：自上而下的方法》第4章。你还可以在维基百科上找到一个简短的解释。



## 分组生命中的一天（A Day in the Life of a Packet）

互联网的4层模型从应用层获取数据流，传输层将此流分解为数据段，并将其可靠地传送到另一台计算机上运行的应用程序。传输层将这些段作为网络层分组发送，网络层将这些分组发送给另一台计算机。让我们看看在实践中，web浏览器和服务器发送和接收的实际分组是什么样子。

![4/2]()

首先，让我们看看传输层。几乎所有的web流量都是通过TCP（传输控制协议）进行的。在它的典型操作中，有一个客户端和一个服务器，服务器侦听连接请求。要打开连接，客户端会发出连接请求，服务器会响应该请求。我不会详细介绍它是如何工作的，但事实证明，这种交换需要三条消息，称为“**三方握手**”。

握手的第一步是客户端向服务器发送一条“**同步**”消息，通常称为**SYN**。第二步是服务器响应“同步”消息，该消息也确认客户端“同步”，或“**同步和确认消息**”，通常称为**SYN-ACK**。第三步也是最后一步是客户端通过**确认**服务器的同步（通常称为**ACK**）来响应。因此，三方握手通常被描述为“同步、同步和确认、确认”或“SYN、SYN-ACK、ACK”。

![4/3]()

回想一下，网络层负责向计算机传送分组，而传输层负责向应用程序传送数据。从网络层的角度来看，发送到同一台计算机上不同应用程序的分组看起来是一样的。这意味着要向另一个程序打开TCP流，我们需要两个地址。第一个是网络协议地址，这是网络层用于向计算机传送分组的地址。第二个是TCP端口，它告诉计算机软件要向哪个应用程序传送数据，web服务器通常在TCP端口80上运行。因此，当我们打开与web服务器的连接时，我们向运行web服务器的计算机发送IP分组，该服务器的目标地址是该计算机的IP地址，这些IP分组具有目标端口为80的TCP段。

![4/4]()

但是这些IP分组是如何到达目的地的呢？我们没有将我的客户端直接连接到服务器的线路。相反，我的客户端连接到一台中间计算机——一台路由器，此路由器本身连接到其他路由器。客户端和服务器之间的IP分组需要许多“跃点”，其中一个跃点是连接两个路由器的链路。例如，由于我的客户端位于WiFi网络上，因此第一个跃点是无线到WiFi接入点的。接入点与更广泛的互联网有有线连接，因此它沿着这个有线跳转发我的客户端分组。

路由器可以有许多连接它的链路。当每个分组到达时，路由器决定将其发送到哪个链路。路由器有IP地址，所以它也可能不转发分组，而是将其传送到自己的软件。例如，当你使用TCP登录路由器时，IP分组将发送到路由器自己的IP地址。

![4/5]()

路由器是如何做出这个决定的？它是通过一个叫做转发表的东西来实现的，如上图所示。转发表由一组IP地址模式和每个模式要发送的链接组成。

当分组到达时，路由器检查哪个转发表条目的模式与分组最匹配。它沿着该条目的链接转发分组。一般来说，“最佳”是指最具体的匹配。我将在关于最长前缀匹配的视频中更详细地描述这种匹配的工作原理。但是在这个简单的例子中，我们只考虑默认路由，上面表中的第一个条目。默认路由是最不特定的路由——它匹配每个IP地址。如果当分组到达时，没有比默认路由更具体的路由，路由器将只使用默认路由。

默认路由在边缘网络中特别有用。比如说，你在斯坦福大学，有一个路由器将你连接到更大的互联网。你的路由器将有许多特定的路由用于斯坦福网络的IP地址：“通过该链接向工程学校发送分组”，“通过该链接向图书馆发送分组。”但是如果目标IP地址不是斯坦福的，那么路由器应该将其发送到更大的互联网。

![视频]()

现在让我们看看真实网络中的一些IP分组。我将从www.brown.edu请求一个网页，并使用一个名为Wireshark的工具向你显示所有分组。我们将看到我的web浏览器如何使用SYN、SYN-ACK、ACK三方握手打开到Brown web服务器的TCP连接，然后开始发出HTTP GET请求，服务器用数据响应该请求。一旦我们看到了我的客户端和布朗大学web服务器之间的分组交换，我将使用另一个名为traceroute的工具来观察这些分组通过Internet的路径。

![补充图]()

所以首先我要启动wireshark。因为我的计算机正在使用许多网络应用程序并发送许多不同的分组，所以我将告诉wireshark仅使用端口80向Brown服务器显示属于TCP段的分组。这样，我们将只看到我生成的web流量。我还将告诉Wireshark收听en1，这是我的Mac电脑给我的WiFi链路层起的名字。如你所见，我有许多可用的链接层，但让我们看看en1，因为这就是我连接到Internet的方式。

接下来，我将打开我的web浏览器并请求布朗大学计算机科学系的网页。这是我本科时去的地方，所以我喜欢了解系里的最新情况。你可以在wireshark中看到，加载此页面需要发送和接收大量分组！Wireshark向我显示了每个分组的时间戳、源IP地址、目标IP地址、它使用的协议、它的长度以及其他信息。看这第一个包，它是从我的电脑（地址是192.168.0.106）到Brown CS web服务器（地址是128.148.32.12）。它将连接到TCP端口80——服务器上的超文本传输协议端口，我们可以从Info列中的>http字段中看到。这些分组是SYN分组——三方握手的第一步。

来看看前三个包。第一个是从我的计算机到web服务器的SYN分组。第二个是从web服务器返回到我的计算机的SYN-ACK分组。第三个是从我的计算机返回到web服务器的ACK。这是三方握手！现在这两台计算机可以交换数据，你可以看到第一个分组是HTTP请求——我的计算机向web服务器发送GET请求。此GET请求的响应是三个分组——wireshark在收到第三个分组时显示响应，如信息为HTTP/1.1 200 OK的行所示。在这里，我们可以看到我如何从Brown的计算机科学服务器请求一个网页，通过三个IP分组创建一个TCP连接，用于三次握手，然后是更多的分组用于HTTP请求和响应。



这就是终端主机计算机在网络层交换分组时网络的样子。但是它在网络层中看起来是什么样子呢？这些分组要经过哪些跳数？要看到这一点，我将使用第二个工具，traceroute。Traceroute向你显示分组到目的地的跳数。因此，我们可以键入traceroute www.cs.brown.edu以查看通过Internet的路径。我将添加-w标志，它指定一个超时，超时时间为1秒。

分组的第一跳是到我的无线路由器，它的IP地址是192.168.0.1。正如你从下一跳看到的，我在家里——我有一个有线调制解调器，互联网提供商是Astound。在此之后，分组需要另一个跳到IP地址为74.14.0.3的路由器。之后的一跳是加州旧金山的一个路由器，然后是圣何塞的几个路由器，sjc代表above.net，sanjose1代表level3.net。在sanjose1.level3.net之后，分组将在纽约的美国各地发送！它们通过纽约的一系列路由器——ebr、csw、ebr，然后在第13跳到达波士顿。波士顿离布朗所在的Providence很近。在oshean.org之后，我们看到了三颗星——这意味着有一个路由器不会告诉traceroute自己。星星是traceroute显示它在等待回复，但回复超时的方式。在第20条，我们看到Brown的CS部门有一台路由器。在那之后，一切都被隐藏了——布朗的CS部门不想让你看到它的网络内部是什么样子。

因为我们看不到布朗的网络服务器的路径，让我们试试另一个：麻省理工学院的计算机科学和人工智能实验室（CSAIL）。我们可以看到，分组沿着相同的路径到达波士顿，直到第15跳。通往布朗的道路在第15跳到达oshean，而通往麻省理工学院的道路在level3的网络中继续。在通往www.csail.mit.edu的路径上，只有两个路由器被隐藏，第13和第19跳。我们可以看到www.csail.mit.edu也被命名为akron.csail.mit.edu，经过22跳之后，我的计算机上的分组到达了麻省理工学院的网络服务器。 看看时间值 -- 我的分组到达麻省理工学院的网络服务器以及它的响应返回给我的时间 -- 来回的时间 -- 不到90毫秒，或者说不到一个眨眼的时间。



我们现在已经看到了分组的生命周期，从应用程序级客户端web请求开始，通过Internet进行近20次跳跃以到达其目的地。对我来说，这是教这门课最好的事情之一：我们所呈现的一切都是你和我每天都要与之互动的——即使只是在看一个视频！在实践中很容易看到这些原则和想法，只需几个简单的工具，你就可以实时检查互联网的运行情况！



## 分组交换原理（Packet switching principle）

当互联网被设计出来时，它是基于一个有争议的、革命性的想法：**分组交换**。如今，它似乎是建立网络的直接和明显的方式，但情况并不总是如此。这是一个非常简单的想法，但当然就像简单的想法一样，一旦你把它付诸实践，就会产生许多有趣的影响。我们将用一整周的时间来讨论分组交换及其影响，但在这段视频中，我们将介绍高层次的想法和它的直接好处。

**分组**：一个独立的数据单位，携带必要的信息到达目的地。

分组交换是指我们将数据分解成离散、独立的数据块。每个块，称为一个分组，携带足够的信息，网络可以将该包送到目的地。因此，假设我们有一个源和一个目的地，在它们之间有一个由分组交换机A、B和C组成的网络。当A收到目的地的分组时，它沿链路将其发送给B；当B收到目的地的分组时，它将其发送给C；当C收到目的地的分组时，它将其发送给目的地。在最简单的分组交换形式中，每个分组都单独且独立地路由。例如，假设有另一个与B相连的交换机，称为D。在向C发送一个分组后，B可以立即向D发送下一个分组。或者，如果下一个分组也是到目的地，它将向C连续发送两个分组。



**分组交换**：对于每个到达的分组，独立地选择其输出链路。如果该链路是空闲的，就发送它；否则，保留该分组以备后用。

下面是分组交换工作的一个例子：每个分组都包含一个明确的路由，指定沿途每个分组交换的ID。我们把这称为 "**自我路由** "或 "**源路由**"，因为源头指定了路由。当源发送一个分组时，它在分组中放入A、B、C、目的地。然后它把分组转发给A。A看了看报头，发现下一跳是B，于是它把分组转发给B。B看到下一跳是C，C看到最后一跳是目的地。事实证明，互联网支持源路由，但它通常被关闭，因为它引起了很大的安全问题。拥有路由器的人不希望你告诉他们如何发送分组，因为你可能会欺骗他们把分组发送到他们不应该去的地方。

一个简单的优化，也是今天互联网主要做的，就是在每个交换机中放置少量的状态，告诉它要把分组发送到哪个下一跳。例如，一个交换机可以有一个目标地址表和下一跳。当它收到一个分组时，它在表中查找地址，并将分组发送到适当的下一跳。在这种模式下，分组需要携带的只是目的地址。使用该地址，沿途的每个交换机都可以做出正确的决定。例如，在我们这里的网络中，A的表说到目的地的分组应该去交换机B，交换机B的表说到目的地的分组应该去交换机C，以此类推。

![5/5]()

在分组交换中，没有专门的电路来承载我们的数据。相反，我们通过给数据块添加一个头部来发送数据，并称其为一个分组。头部包含了分组要去的地方的地址，就像一个信封告诉邮局要把一封信寄到哪里。

一个分组交换网络由终端主机、链路和分组交换机组成。当我们发送一个分组时，它被逐跳路由到其目的地。每个分组交换机在其本地转发表中查找分组头的地址。

例如，这个分组的地址是B。当我们发送它时，第一个路由器在其本地表中查找地址B，并看到交换机S2是下一跳。S2和S4做了同样的事情，分组最终被送到了B。在互联网上有几种不同类型的分组交换机。其中一些被称为**路由器**或**网关**，而另一些被称为以太网交换机。稍后我们将了解更多关于它们的信息。在这个阶段，你只需要知道它们都是分组交换机的类型，并且它们根据头部中的目标地址转发分组。



![5/6]()

（这一部分似乎真的是基于基于电路的网络，许多学生从来没有使用过这种网络，为什么你需要每个流的状态？为什么你不能有效地共享链路？）包交换有两个非常好的特性。首先，交换机可以为每个分组做出单独的、本地的决定。它不需要保留关于它所看到的分组的额外状态，也不需要保留两个分组是否去往同一个目的地。即使许多分组是一些更大的传输或协议的一部分，交换机也不需要知道或关心。交换机不需要知道有些分组是Skype电话，有些是网络请求，还有一些是你电脑的固件更新。它只是转发分组。这大大简化了交换机的工作。

第二点是它让交换机在多方之间有效地共享一个链路。例如，考虑一个家庭中的无线路由器，有两个人在他们的笔记本电脑上浏览互联网。如果一个人正在阅读一个网页，那么另一个人可以以链路的全速下载一个文件。如果第一个人开始加载一个新的网页，那么这个链路就可以在他们两个人之间共享。一旦下载完成，第一个人就可以使用该链接的全速。

这两点真的很重要，所以我们将对这两点进行一些更详细的讨论。



当然，当我们通信时，我们通常不会只发送一个分组，我们会发送很多；例如，一个语音电话由许多连续的分组组成，都是同一通信的一部分。我们把这种分组的序列称为流，更具体地说：

**流**是属于同一端到端通信的数据报的集合，例如，一个TCP连接。

让我们先来看看每个分组的独立路由。

因为每个分组都是独立的，所以交换机不需要知道分组组或分组流的情况。想象一下，如果每个交换机都必须跟踪经过它的每一个网络连接。这将需要大量的状态，难以管理。相反，独立处理每个分组意味着交换机可以更简单地建立、管理和排除故障。

交换机不需要担心添加或删除这种每个流的状态。想象一下，如果每次你想加载一个网页，你必须与路径上的每一个交换机沟通，以设置状态，使你的请求能够发挥作用。这可能会使事情变得更慢。相反，你只需发送分组，交换机就会适当地转发它们。

交换机也不需要储存这种状态。因为交换机必须是快速的，如果他们需要将这种状态存储在非常快的内存中，那么会非常昂贵。这使得交换机可以专注于做一件事，快速转发分组。

最后，这意味着交换机不需要担心故障问题。例如，想象一下，当你开始一个网络请求时，但你的平板电脑没电了，会发生什么？交换机要为请求保留每个流的状态，但如果创建该状态的一个节点发生故障，交换机需要知道如何清理它。否则，你可能会有几百万、几十亿的死流在消耗你的内存。在包交换中，交换机没有每个端点的状态。如果你的平板电脑死了，交换机并不关心，这只是意味着它停止接收来自它的分组。通过这种方式，交换机在功能上与通过它发送流量的计算机更加独立。



想想你通常如何使用互联网——你的使用是突发的。你加载一个网页，然后阅读它，然后加载另一个。 你从 iTunes 下载几首歌曲，然后聆听它们。 你从 Netflix 播放一个节目四十五分钟，然后停止。 数据流量是突发性的：随着时间的推移，使用量不是总是以固定速率发送和接收数据，而是起起落落。

虽然数据流量有大范围的变化和高峰——下午 3 点通常很高，晚上 8 点也是如此，而凌晨 2 点则很低，但在较小的范围内，它非常突发，而且这些突发通常是独立的。假设你和你的朋友都在咖啡店浏览网页。你和你的朋友加载一个新页面时大多是独立的。有时它们可能会（时间）重叠，但通常它们不会。通过将你的所有流量视为分组，无线路由器可以非常有效且简单地在你之间共享其容量。如果你在朋友阅读时加载页面，无线路由器可以将其所有容量分配给你的分组。同样，如果你的朋友正在加载页面而你正在阅读，则路由器可以将其所有容量分配给你朋友的分组。链接不需要因为你们中的一个人不使用它而部分闲置，并且如果你们都在使用它，那么链接可以在你们之间共享。

这种以概率或统计方式获取单个资源并在多个用户之间共享的想法称为**统计复用**。它是统计性的，因为每个用户都会根据其他人的使用量获得资源的统计份额。例如，如果你的朋友正在阅读，你可以使用所有链接。如果你们两个都在加载一个页面，你将获得一半的链接容量。



因此，这就是分组交换的两个主要好处：

- 它使交换机变得简单，因为它们不需要知道分组的流量。
- 其次，它让我们在共享一条链路的许多流量之间有效地分享容量。

这种简单的构件在当时是革命性的，但它现在已被接受为构建网络的常见方式。



## 分层原则（Layering principle）

在过去的几个视频中，你已经看到了很多关于分层的内容，特别是在描述四层互联网模型分层的视频中。分层是非常广泛使用的原则，并且在互联网出现之前已经在网络中使用了几十年。事实上分层是一个在网络之外广泛使用的设计原则，它在许多许多类型的计算机系统中都被作为设计原则使用。 

分层有很多原因，我们将探讨其中一些原因。在这段视频中，我们将探讨什么是分层，我们将看看通信和计算机系统中分层的一些简单例子，我们将解释为什么这么多系统都是分层的，要么是自然发生的，要么是故意设计的。

让我们从分层的定义开始，分层是我们将一个系统组织的名称，分为一些独立的功能组件或层。各层是分层的，它们按顺序进行通信，换句话说，每一层都有一个接口，只与上面和下面的层相通。每一层都为上一层提供一个明确定义的服务，使用下面各层所提供的服务和自己的私有处理，向上面的层提供明确的服务。

![6/2]()

在日常生活中，有许多关于分层的例子，特别是当一种服务被故意或自然地建立在另一个服务之上时。例如，如果你正在寻找飞机票，你可能会访问一个经纪网站，如谷歌航班Hipmunk或Kayak，这些网站让你通过与某个单一的服务沟通来寻找各种航空公司的机票，而不是去每个航空公司的网站查询他们有哪些机票，经纪网站是在每个航空公司之上为你提供一个服务层，为你抽象出每个航空公司网站的细节。

现在，如果我们看一下每家航空公司的封面，他们在不同的航线上驾驶不同类型的航班，航班负责提供服务的细节，并向你提供一张简单的抽象的机票，有效地将你带到两个机场之间，他们也隐藏了许多其他的细节，例如，在许多情况下，他们有许多供应商提供膳食，饮料，燃料等等，这些都是自然地隐藏在我们消费者面前。

这种关注点的分离使层次结构中的每一层都能专注于做好自己的工作，并为上一层提供明确的服务。



![6/3]()

另一个众所周知的、更接近互联网的例子是邮政服务。想象一下，我有一本书想寄给Phil，我把书放在一个信封里，加上Phil和我的地址，然后把它交给Olive，让他把信送到邮箱里，邮政部门对邮件进行分类，然后通过各种不同的方式发送，飞机、邮车、火车等等，直到到达Phil附近的分拣处。邮递员把信交给Phil，Phil打开信，发现里面有一本书。

服务的层次很清楚，我不关心信是怎么从我这里送到Phil手里的，是坐飞机卡车还是气垫船，我也不关心这本书走的是什么路线，沿途经过多少个分拣处，我不关心Olive是走着去的还是骑着去的还是跑着去的，我不关心他把信放在哪个邮筒里。我希望下层为我抽象出细节，为我提供一个简单的服务模型：我把书放在信封里，下面的层把它送到Phil那里，反过来，Olive也不需要知道邮政服务是如何送信的，他只是通过邮寄信件与下面的层进行沟通，Phil只是想要这本书。注意，每个层只与上面和下面的层进行沟通，如果邮政部门部署了新的火车或开始使用不同的航空货运服务，Phil和我不需要知道。 我们可以随着时间的推移独立地改进每一层，例如，如果我想更快地保证交货，我可以把信封交给DHL或Fedex等承运人，接口几乎是一样的，我只需给他们一个信封和钱。

![6/4]()

分层是许多计算机系统中有意设计的，当我们编写程序时，我们使用一种语言创建源代码，抽象出操作系统的细节，虚拟内存是如何工作的，低层的硬件是如何工作的。好吧，C语言在隐藏细节方面并不出色，但许多其他语言，如java和python，都有意让我们远离低层的工作方式。作为一个程序员，我们通过把源代码交给编译器来与编译器下面的层进行交流。 编译器是一个独立的功能组件，它负责几个任务，如代码预处理、词法分析解析、代码生成和优化，编译器生成目标代码，然后将其传递给链接器，将编译后的目标文件和库链接在一起，生成一个可执行文件，然后由CPU实际或虚拟执行代码，如果你有编写计算机程序的经验，分层的好处是相当清楚的。



在这个例子中，分层将编写在硬件上执行的程序的整体问题分解为模块或功能组件，每个模块都有明确的作用，并为上面的层提供明确的服务，它还提供了明确的关注点分离，编译器可以专注于词法分析解析等，链接器可以专注于有效地将对象拼凑在一起，两者都不必担心其他的工作，并且随着技术和知识的进步，每个人部分可以改进、升级和替换。 例如，我们可以用gcc替换商用c语言编译器，反之亦然，而不需要改变链接器或我们使用的语言。 当Nick第一次起草这些幻灯片时，我很高兴他把编译器作为分层的一个例子，这既是分层的好处，也是有时你需要打破分层的一个很好的例子。

一般来说，一段c代码可以被编译给几乎任何处理器使用，比如i++，我们可以将其编译给arm处理器和手机x86 64处理器和笔记本电脑或微控制器或超现代洗碗机使用，这样c代码是硬件独立的，因此它保持了这里的分层。但有时我们需要我们的c代码代码做一些只有我们的处理器才能做的特殊事情，例如x86 64处理器有微控制器没有的各种特殊指令。

c提供的分层隐藏了这个细节，所以它不允许你直接这样做，但你必须这样做来实现你的目标。还好操作系统内核包括汇编代码，但这样做意味着代码不再是独立于层的，因为为arm编写的linux上下文切换汇编只适用于arm，所以你必须为每一层编写不同版本的代码，如果linux想在一个新的处理器上运行，开发者需要为该处理器编写新的汇编代码。所以这是一个很好的例子，因为它显示了层的好处，即分离关注点并简化你的系统，就像C语言编程比汇编容易一样；但有时你必须打破层的界限，这样做有一个巨大的代价，突然你不再独立于下层，大大限制了灵活性，但只有在你真的必须这样做的时候你才应该这样做。

正如我们将看到的那样，今天互联网中的许多实际操作挑战是由人们打破分层和假设他们的服务接口上下的东西造成的。我们将看到一个很有说服力的例子，那就是被称为NATS或网络和网络地址翻译器的东西，它是一个非常有用的设备，但不幸的是，它使互联网几乎无法增加新的传输协议。 

正如我们将看到的那样，今天互联网中的许多实际操作挑战是由于人们打破了分层，并假设了其服务界面之上和之下的东西，通过进行跨层优化来改善互联网，以及由此导致的灵活性的丧失，我们将看到一个真正有说服力的例子，即称为Nats或网络和网络地址转换器的东西，这是一个非常有用的设备，不幸的是，它使互联网几乎无法增加新的传输协议。

总之，我们使用分层和计算机系统模块化有五个主要原因：

1. 它将系统分解成更小的、更容易管理的模块。
2. 它是一种定义明确的服务，每一层都为上面的层提供一种定义明确的服务。
3. 重用上面的一层可以依靠其他人的努力工作来实现下面的层，这使我们在建立一个新系统时省去了编写每一层的时间。
4. 关注点分离，每一层都可以专注于自己的工作，而不必担心其他层如何做他们的工作。唯一的通信是在层与层之间，所以它有助于保持一个层的处理和数据的本地和内部，尽可能减少层之间的复杂互动。
5. 第五，它允许对每个功能进行持续改进。
6. 特定于分层通信系统， 例如点对点通信的互联网。在四层互联网模型中，我们看到了每一层是如何使用下面的层提供的服务与另一个系统中的同伴进行通信的。同样，在邮件的例子中，菲尔和我是作为用户互相通信的，不用担心通信服务如何工作。

![6/6]()



## 封装原则（Encapslation principle）

这个视频是关于我们称之为**封装**的架构原则。封装是你把层和分组交换结合起来后的结果。我们想把数据分解成不连续的单元，称为分组。然而，每个分组都包含来自多个层的数据。例如，当你发送一个TCP段时，它在一个IP包内，而IP包又在一个以太网帧内，封装就是这样工作的。封装是一种原则，你通过它来组织分组中的信息，这样你就可以保持各层，但又让它们共享分组的内容。

![7/2]()

回顾一下，分层让你把一个复杂的系统分解成更小的部分。每一层都提供一种服务，是对其上面各层的网络的一种抽象，它通过使用它下面的层来提供这种抽象。每个层都是自成一体的，所以只要它提供了预期的服务，上面的层就不需要担心如何提供。这种关注点的分离意味着每一层都可以独立发展。就像网络层的IP不需要担心传输层的TCP的变化一样，应用层如HTTP也不需要担心TCP的变化。例如，在过去的几年里，大多数操作系统都改变了它们使用的TCP算法，以更好地处理不断增长的网络速度，但网络浏览器使用旧的算法和新的算法都能正常工作。

请注意，这图片有7层OSI模型。

![7/3， 7/4]()

让我们回到4层模型。

封装的原理是让我们采用协议层，并让它们轻松地共享分组中的存储。这是分层在实际数据表示中的体现方式。这种工作方式是每个协议层都有一些头部，然后是它的有效载荷，最后是一些脚部。例如，一个IP包头部有一个源地址和一个目标地址。为了用IP发送一个TCP段，我们把TCP格式作为IP包的有效载荷。这样一来，IP包就 "封装 "了TCP段。IP不知道也不关心它的有效载荷是什么，它只是把分组送到终端主机。当分组到达时，主机查看有效载荷，看到它是一个TCP段，并对其进行相应的处理。

所以这里有一个更完整的例子。假设你正在使用一台通过WiFi、无线以太网连接的电脑浏览网页。你的网络浏览器产生了一个HTTP GET请求。这个HTTP GET请求是一个TCP段的有效载荷。封装HTTP GET的TCP段是一个IP分组的有效载荷。这个IP分组，封装了TCP段和HTTP GET，是一个WiFi帧的有效载荷。如果你要看一下你的电脑发送的字节，它们看起来像这样。最外层的封装格式是WiFi帧，里面是一个IP包，里面是一个TCP段，里面是一个HTTP GET。

![7/5 foot]()

菲尔：尼克是如何画出这个分组可能会带来一些你可能会觉得困惑的东西！你知道吗？事实证明，有两种方法来绘制分组。这种区别来自于背景和你所工作的系统的哪一部分。尼克在这里画了一个分组，标题在右边。分组的第一部分在右边，分组的最后部分在左边。

尼克：这完全说得通。当路由器或交换机发送分组时，我们画出分组从左到右移动。因此，第一个离开路由器或交换机的比特在最右边。

![7/6 head]()

菲尔：但我画的是另一种方式的分组，即头部在左边，脚步在右边。像这样。

菲尔：这种方法来自于软件。当你阅读IETF文件和许多其他协议规范时，你会看到这种方法。这个想法是，分组的开始是在地址零处。所以头部的第一个字节是在地址零处。由于地址从左到右增加，这意味着分组的开始在左边，分组的结束在右边。

尼克：这里没有正确的方法，也没有错误的方法。两种绘制分组的方法都很有价值，取决于你要用这种方法做什么。你应该对两种方式都感到满意。我一般会把头部画在右边。

菲尔：而我一般会把它们画在左边。尼克的背景是电气工程和交换机设计，我的背景是计算机科学和协议软件。

菲尔：现在让我们回到尼克的例子，一个HTTP GET在一个TCP段里，（HTTP + TCP）在一个IP包里，（HTTP + TCP + IP）在一个WiFi帧里。让我们用Wireshark看看这在实际网络中是什么样子。在我们开始记录之前，我打开了Wireshark并记录了一个网络请求的分组追踪。让我们只看一个分组。在这里，我们可以看到Wireshark是如何告诉我们，这是一个以太网帧，里面是一个IP包，里面是一个TCP段，里面是一个HTTP GET。如果我点击这些协议头的每一个，那么Wireshark实际上突出了它们在分组字节中的位置，下面是这些乱七八糟的东西。WiFi是第一位的。WiFi里面是IP。在IP里面是TCP。而在TCP里面，我们可以看到我们的HTTP GET的文本!

![补充]()

菲尔：这种非常简单的将协议相互封装的方法给了你巨大的灵活性。到目前为止，我们一直在谈论4层模型，认为它是完全静态和不灵活的东西。在实践中，它并不是这样的。你实际上可以使用封装来递归层协议。例如，今天在办公室和企业中非常常用的东西是一个叫做**虚拟专用网络（VPN）**的东西。通过虚拟专用网络，你打开一个安全连接到一个你信任的网络，例如你的办公室，例如使用**传输层安全（TLS）**。当你与互联网通信并发送IP分组时，你不是正常发送，而是在这个VPN连接内发送。

因此，IP分组会进入你的办公室网络。在这一点上，办公室网络可以正常路由它们。这让你可以做一些事情，如访问办公室里的私人、受保护的网络资源。与其到处撒网保护，你只需小心对待一项服务，即让人们通过虚拟私人网络登录网络的服务。你用一个网关来做这件事，这台电脑接受来自允许的VPN客户的连接，并将其流量转发到私人网络。

那么，这看起来像什么呢？比方说，我正在访问我的公司内部网站。好吧，我的网络浏览器生成一个HTTP GET。像往常一样，它把它放在一个TCP段里，然后把它放在一个IP包里，目的地是公司的内部网络服务器。但是，我的电脑并没有把这个IP包放在一个链路层的框架内，我不能直接与内部网络服务器进行通信，而是把这个IP包放在一个TLS段内。

TLS保护信息并使其保密。此TLS会话位于终止于虚拟专用网络网关的TCP流中。因此，外部TCP段位于目的地为虚拟专用网络网关的IP分组内。我们把这个外部IP包放在一个链路帧内，并把它发送到下一跳。所以它看起来像这样。HTTP里面的TCP里面的IP里面的TLS里面的TCP里面的IP里面的以太网。

尼克：现在你已经听说过封装了，这是统一分层和分组交换的原则。封装是我们如何利用协议层，并以一种灵活的方式将它们组装成分组，并保持它们之间的分离。你看到了一个计算机可以封装一个网络请求的例子，以及一个如何以更复杂的方式使用封装的例子，如虚拟私人网络。



## 比特顺序（byte order）

为了让双方进行沟通，他们需要就他们交换的信息达成一致。

如果一方认为信息是西班牙语，而另一方认为是柬埔寨语，他们将无法沟通。对于计算机通信来说，这意味着同意信息有哪些字段，如何安排和格式化，以及如何表示它们。为了生成一个要发送的信息，软件通常要在内存中创建一个副本，然后将其传递给网卡。同样，当计算机收到一个信息时，网卡会把这个信息放在内存中，然后软件就可以访问它。如果你想了解网络协议和编写网络协议软件，了解这些工作原理和你可能遇到的一些陷阱是很重要的。

![8/2]()

因此，让我们从计算机内存的一个简单模型开始。在今天的大多数计算机中，内存是以字节为单位组织的：8比特的内存块。一个程序有一个地址空间，从地址0开始。今天的大多数计算机都是64位的：这意味着内存地址是64位的，所以一台计算机最多拥有2的64次方个字节，或者18个六亿字节。实际上，今天的计算机没有这么多内存：它们有千兆字节，也就是2的30次方。在这个例子中，我们的计算机有8GB的内存，所以它的最大地址是上图所示的十六进制值。软件可以访问这个内存的每一个字节，也可以成组访问字节，比如用一条指令从8个连续的内存字节单元加载一个64位的整数。

![8/3]()

但计算机如何表示一个多字节的值呢？比方说，我们想表示数字1,024，在十六进制中是0x0400，或4次乘以256。
这个值需要16位，或两个字节。哪个字节在前：0x00还是0x04？如何在内存中布局多字节值称为endianness，有两种选择。在小端中，最低有效字节位于最低地址，所以最低有效字节在内存中排在第一位。事实证明，从计算和架构的角度来看，这是最合理的。另一个选择是大端，其中最高有效字节是最低地址。对人类读者来说，大端更有意义，因为这就是我们写数字的方式，最重要的数字在前。



### 测验

$$
\begin{array}{lrrrr}
\hline \text { Width} & \text { Decimal} & \text { Bytes}& \text { Big Endian}& \text { Little Endian} \\
\hline 16 \text { bits } & 53 & 0\mathrm x3500  &\mathrm{False} &\mathrm{True}   \\
16 \text { bits } & 4116 & 0\mathrm x 1014  &\mathrm{True} &\mathrm{False}\\
32 \text { bits } & 5 & 0\mathrm x 00000005&\mathrm{True} &\mathrm{False} \\
32 \text { bits } & 83,886,080 & 0 \mathrm x 00000005  &\mathrm{False} &\mathrm{True}\\
32 \text { bits } & 305,414,945 & 0 \mathrm x 21433412 &\mathrm{False} &\mathrm{True} \\
\hline
\end{array}
$$

这是一个测验。对于每个数字，标记十六进制表示是大端还是小端。不要使用计算器或其他工具！

- 53是小端表示。53是3乘以16加5，0x35在第一个字节中。
- 4116是大端表示。4116等于4096加20。所以这两个字节是0x10和0x14，其中0x10是表示更高有效位的字节，即4096的字节。由于十六进制是0x1014，这意味着最高有效字节排在第一位，并且是大端。
- 5是大端表示。最低有效字节是最后一个，具有最高地址。
- 83886080是小端表示。它是2的24次方的5倍，所以这意味着0x05是最高有效字节。
- 305414945是小端表示。我没有试着找出这张表上的所有数字，而是只看了最低有效位。最低有效位是0x21或0x12的一部分。如果是0x21，最低有效位是1，则该数字为奇数。如果是0x12且最低有效位为8，则该数字为偶数。由于305414945是奇数，这意味着0x21是最低有效字节，数字以小端存储。



### 网络比特顺序

那么，为什么这很重要呢？如果两台计算机要进行通信，它们需要就它们是用大端还是小端格式表示数字达成一致。由于不同的处理器使用不同的编码方式，这就很复杂了。例如，英特尔和AMD的x86处理器是小端：最低有效字节在前。相反，ARM处理器，如iPhone中的处理器，则是大端，最高有效字节在前。

我们不希望两台计算机关心或知道另一端是大端还是小端。因此，协议规范机构通常会选择一个，并坚持使用它。对于互联网来说，这意味着大端。所有作为互联网规范的协议都使用大端格式。

这里有一个C代码的例子，它可以告诉你你的计算机是大端还是小端。它需要一个16字节的值，并向其传送一个指针，让代码单独查看这些字节。如果索引0的字节是0x40，则最高有效字节排在第一位，是大端。如果索引1的字节是0x40，那么它就是小端。如果两者都不是，那就说明发生了奇怪的事情。

![8/5]()



### 可移植的程序代码

但是等等，这会造成一个复杂的问题。你需要一个大端格式的分组，但是如果你的处理器是小端格式呢？例如，假设你希望将TCP段的端口号设置为80，即HTTP端口。一个简单的方法是创建一个C结构，在正确的偏移量上有一个字段端口。但是，如果使用值80与端口字段进行比较，它将以小端存储，第一个字节为0x50。大端要在第二个字节中存储0x50。因此，尽管段中的端口字段为80，但此测试将失败。

为了简化此过程，C网络库提供了在主机顺序和网络顺序之间转换的实用程序函数。例如，函数htons()将主机的16位值作为参数，并按网络顺序返回值。还有用于将网络短消息转换为主机短消息的函数，以及用于长消息、32位值的函数。因此，测试分组端口是否为80的正确方法是读取分组结构的端口字段，并调用ntohs将其从网络顺序转换为主机顺序。然后，你可以将其与80进行比较，得到正确的结果。在小端结构的情况下，NTOH和HTON颠倒了两个字节的顺序。对于大端体系结构，它们只返回未更改的值。

![8/6]()



### 处理网络数据时要小心！

这些函数为你提供了机制，通过这些机制你可以编写独立于处理器架构的网络代码。但是要小心！我怎么强调都不过分：处理网络数据时要小心。如果你在主机和网络顺序之间转换时没有原则性和严谨性，那么你会感到非常头痛，因为你忘记转换或无意中转换了两次，突然你的协议出现错误或触发各种奇怪的错误。



### 包格式

![8/8]()

现在我们知道了Internet规范是如何按照网络顺序或大端排列多字节值的，我们可以看看互联网规范是如何描述其分组格式的。由于历史原因，互联网规范是以ASCII纯文本编写的。左边的文本块是从Request for Comments (RFC) 791中逐字摘录的，它规定了IP协议的第四版，即IPv4。上面显示了从0到31的位数——分组的宽度为4字节。由于IPv4有5行必填字段，这意味着一个IPv4头至少有20字节长。尼克和我经常在显示分组时使用一种更简单的可视化格式，比如右边的那个。

以此为例，IPv4分组的总长度字段为2字节，或16位长。这意味着IPv4分组的长度不能超过65535字节。分组中的该字段以大端存储。长度为1400字节的分组存储为0x0578。因此，该长度的IP分组的第三个字节是0x05。



让我们在wireshark中看到这一点。我要开始wireshark并监听分组。第一个分组是关于一个叫TLS的东西，或者叫传输层安全。这是网络浏览器用于安全连接（https）的方式。TLS对我们隐藏了分组的数据，但我们仍然可以看到它的头。使用wireshark，我们可以看到TLS的有效载荷在一个TCP段内，该TCP段为443端口，是标准的TLS端口。此TCP段位于IPv4标头内，详细查看IPv4报头，我们可以看到分组的总长度字段是1230。1230的十六进制是0x04ce:1024，或0x04乘以256加106，或0xce。在底部，Wireshark向我们显示了分组的实际字节数。这就是，04ce，在大端，或网络顺序中。

你已经看到了不同的处理器如何以不同的方式排列数字。但由于网络协议需要达成一致，协议规范决定了数字的排列方式，这可能与处理器不同。为了帮助实现这一点，C网络库提供了在主机和网络顺序之间转换的帮助函数。但要小心使用！随意使用它们很容易让你损失很多调试时间，如果你在开始并决定在代码中转换的原则性方法时非常小心，那么这是可以避免的。



## IPv4地址（IPv4 addresses）

互联网协议允许两台计算机在一个由许多不同链路层构建的网络上交换信息，它通过地址来实现。一个IP分组有一个源地址和一个目的地址。路由器根据分组的目的地址决定将分组转发到哪个链路。让我们详细了解一下IPV4是什么样子的，它们是如何格式化的，以及它们是如何分配的。



### 因特网协议地址的目标

互联网协议的最初目标是将许多不同的网络拼接在一起。为了实现这一目标，协议需要一种独立于其所在网络的、独一无二的方式来指代一台计算机。因此，IBM网络上的计算机和通过串行线连接到路由器的计算机可以相互交谈，并且需要一种相互寻址的方法。

今天，IPv4地址有点复杂，由于一堆特殊情况和用途，它们不是完全唯一的，但现在让我们假设它们是唯一的。



### IPv4

![9/3]()

一个互联网协议第4版的地址是32位长。这32位通常被写成4个八位数，4个8位值，形式为a.b.c.d，例如171.64.64.64，128.30.76.82，以及12.22.58.30。每个通过IPv4连接的设备都有一个IP地址，IP层将目的地为该地址的分组传送给该设备。

除了地址，一个设备通常还有一个叫做**网络掩码**的东西。网络掩码告诉设备哪些IP地址是本地的，在同一链路上，哪些需要通过IP路由器。例如，想想无线网络上的一台笔记本电脑。为了向同一无线网络中的另一个设备发送分组，笔记本电脑不需要通过一个IP路由器。理论上，它可以直接将分组发送给其他设备，因为它处于同一链路上。

一个网络掩码被写成一串连续的1，从最高有效位开始。例如，一个255.255.255.0的网络掩码意味着前三个八位数都是1（$2^8-1=255$），最后一个八位数是0。这意味着与你的IP地址的前三个八位数，24位，相匹配的IP地址是在同一个网络中。255.255.252.0的网络掩码意味着网络掩码是22位，而255.128.0.0是9位网络掩码。

通过使用网络掩码对两台计算机的地址进行位AND运算，可以判断它们是否在同一网络中。如果所得的地址相等，它们就在同一个网络中。



让我们看看这在我的电脑上是什么样子。我可以打开一个终端，使用ipconfig程序。我的电脑通过WiFi连接到互联网，这恰好是名为 "en1 "的链接。如果我们看一下 "en1 "里面的信息，我们可以看到我的互联网协议版本4地址是192.168.0.106，我的网络掩码是0xffffff00，这是十六进制的255.255.255.0。这意味着，如果我向以192.168.0开头的地址发送IP分组，我应该直接发送，但如果它不是以192.168.0开头，我需要通过路由器发送。



### 测验

$$
\begin{array}{llll}
\hline \text {Source} & \text {Destination} & \text {Netmask} & \text {Same Network?} \\
\hline 128.34 .1 .15 & 128.35 .1 .15 & 255.255 .0 .0 & \mathrm{False}\\
10.0 .1 .4 & 10.0 .1 .5 & 255.255 .255 .0 &\mathrm{True}  \\
10.0 .1 .4 & 10.0 .2 .5 & 255.255 .255 .0 &\mathrm{False} \\
171.64 .15 .33 & 171.64 .15 .5 & 255.255 .255 .224 & \mathrm{False} \\
171.64 .15 .33 & 171.19 .201 .2 & 255.0 .0 .0 &  \mathrm{True}\\
\hline
\end{array}
$$

这是一个测验。对于每个源、目标和网络掩码，标记目标是否与源位于同一网络中，让我们浏览一下答案。

- 第一行的答案是否定的。他们在不同的网络中。这两个地址的第二个八位组不同，分别是34和35。如果我们使用网络掩码对两个地址进行位AND运算，则得到128.34.0.0和128.35.0.0，这两个地址是不同的。
- 第二行的答案是肯定的。他们在同一个网络中。如果使用网络掩码对两个地址进行位AND运算，则在这两种情况下都得到10.0.1.0。
- 第三行的答案是否定的。它们不在同一个网络中，因为它们的第三个八位组不同。源位于网络10.0.1.0中，而目标位于网络10.0.2.0中。
- 第四排的答案是否定的。它们在同一个网络中。想想最后一个字节。左边带33的地址是0x21。右边的地址是0x05。224是0xE0，即三位。由于源已设置此位，但目标未设置，因此它们不匹配。与网络掩码AND一起，源地址为171.64.15.32，而目标地址为171.64.15.0。
- 最后一行的答案是肯定的。它们在第一个字节中匹配：当与网络掩码AND时，两者都是171.0.0.0。



### 地址结构（历史）

![9/6]()

那么，IP地址是如何分配的呢？最初，它们被分成三类：A类、B类和C类。每类将IP地址分成两部分，即网络和主机。地址的网络部分表示一个管理域，如MIT、BBN或斯坦福大学。地址的主机部分表示该网络中的哪个设备。A类地址有一个前导0，7位网络（用于128个网络）和24位主机，因此可以覆盖1600万台计算机。B类地址有16位的主机，所以可以覆盖65,536台计算机。C类地址有8位的主机，所以可以覆盖256台计算机。



### 网络结构（如今）

![9/7]()

虽然A、B、C类很简单，但我们很快发现它们不够灵活。例如，麻省理工学院和斯坦福大学都收到了第一批A类地址块之一——超过400万个地址。有一段时间，麻省理工学院会给每个宿舍提供相当于B级的服务——几百人有65000个地址！当IP地址很多的时候，这不是一个问题，但随着他们的使用增加，我们需要一个更好的分配政策。

一个有用的说明：斯坦福大学在1999年放弃了它的A类区块，麻省理工学院仍有它的。

今天，IPv4地址的结构被称为**CIDR**，即**无类域间路由**。CIDR允许前缀为任意位数，而不是只有长度为8、16和24位的前缀。这意味着所有CIDR前缀定义的地址块的大小是2的幂。当我们谈论一个CIDR地址时，我们指的是它的网络掩码长度。因此，例如，当我们谈论一个 "斜杠16 "时，我们指的是一个长度为16的网络掩码。这个CIDR块描述了$2^16$个地址，即65,536。当我们谈论 "斜杠20 "时，我们指的是一个长度为20的网络掩码。这个CIDR块描述了$2^{12}$个地址，或者4096个地址。CIDR块是今天地址的结构、地址和管理方式。

斯坦福大学今天有$5\ / 16$块，大约325,000个IPv4地址。



### IPv4地址分配

那么，IPv4地址是如何分配和管理的呢？有一个叫IANA的组织，代表互联网号码分配机构。最终的权威机构是ICANN，即互联网名称与数字分配公司，ICANN将工作委托给IANA。

IANA将描述1600万个地址的slash-8s分配给区域互联网注册机构（Regional Internet Registries），或称RIRs。每个大陆都有自己的RIR。美国的RIR是ARIN，而西太平洋的RIR是APNIC。这些RIRs各自有自己的政策，如何将slash-8分成更小的地址块，并将它们分配给需要它们的各方。

你可能已经在新闻中读到，我们已经用完了IP地址。这并不是真的——今天有许多未使用的地址。所发生的事情是，IANA已经没有slash-8的地址可供分配了。它在其章程中达到了一个特殊的终点。当减少到最后5个$ / 8\mathrm s$时，IANA把一个/8给了每个RIR。现在，地址管理和分配是由RIRs决定的。2012年，时任互联网架构委员会成员的Jon Peterson在斯坦福大学发表了一篇关于这引起的一些政治、经济和技术问题的演讲。该讲座不是本课程的必修材料，但我强烈推荐。现

在你已经看到了IPv4地址的结构，它们是如何被分配的，以及终端主机是如何做出第一跳路由决定的，也就是说，是否发送至本地节点或其网关路由器。今天的地址是以CIDR块来管理和分配的，其大小由前缀长度决定。一个较短的前缀，例如/8，比一个较长的前缀，例如/10是一个更大的块。



## 最长前缀匹配（Longest prefix match(LPM)）

互联网路由器可以有许多链接。它们有许多选项来选择转发一个收到的分组的方向。为了选择转发分组的链接，今天的路由器通常使用一种称为最长前缀匹配的算法。



### 流内部

![10/2]()

在这个例子中，客户端希望在端口80（web服务器的典型端口）上打开与服务器的TCP连接。建立连接和传输数据的分组在客户和服务器之间要经过许多跳。在每个分组的每一跳上，路由器决定通过哪个链路转发分组。



### 每一跳内部

![10/3]()

路由器是如何做出这一决定的？它是通过一个叫做**转发表**的东西来实现的，如右图所示。一个转发表由一组部分IP地址组成。x表示这些地址是部分的，x代表通配符。例如，第二个条目171.33.x.x表示 "任何第一个字节是171，第二个字节是33的IP地址"。例如，这个特定条目包括171.33.5.245以及171.33.1.1。

当一个分组到达时，路由器会检查哪个转发表项与该分组最匹配，并沿着与该转发表项相关的链接转发该分组。我所说的 "最佳"，是指最具体的。默认路由实际上是所有的通配符——它匹配每一个IP地址。如果当一个分组到达时，没有比默认路由更具体的路由，那么路由器将只使用默认路由。



### 最长匹配

![10/4]()

最长前缀匹配，或LPM，是IP路由器用来决定如何转发分组的算法。每个路由器都有一个转发表。这个转发表的条目有两部分：描述一个地址块的CIDR条目，以及匹配该CIDR条目的分组的下一跳。一个地址可能属于多个CIDR条目。

例如，在右边这个路由表中，有两个条目，一个是默认路由，它的前缀长度为0，另一个是171.33.0.0/16。默认情况下，所有分组都会通过链路1。然而，如果分组目标地址的前16位，即两个八位数，与171.33相匹配，路由器将通过链路5发送它。这是因为16位的前缀比0位的前缀长，它更具体。



### 每一跳内部（实际）

![10/5]()

让我们回到先前的例子，在那里我们展示了一个用X表示通配符的转发表，这里是路由器和它的转发表。

![10/6]()

如果我们将这个转发表表示为CIDR条目，它就是这个样子。因为在这个简单的示例中，所有前缀都是以字节为单位的，所以所有前缀的长度都是0、8、16或24位。



### 测验

![10/7]()

在右侧的转发表中，使用最长前缀的路由器将通过哪个链路发送具有以下IP目标地址的分组？

- 对于A，63.19.5.3，答案是链路3。63.19.5.3匹配两个前缀：默认路由和前缀63.19.5.0/30。前缀长度为30位，63.19.5.3仅在最后两位不同，/30是比/0长的前缀，因此路由器将选择链路3。
- 对于B，171.15.15.0，答案是链路4。171.15.15.0匹配三个条目。它与默认路由，171.0.0.0/8和171.0.0.0/10匹配。它与171.0.15.0/24不匹配，因为B的第二个八位组是15，而不是0。第三个匹配项171.0.0.0/10是最长的前缀，因此路由器沿链路4发送分组。
- 对于C，63.19.5.32的答案是链路1。最长前缀匹配是默认路由。它与63.19.5.0/30不匹配，因为它在第26位不同。
- 对于D，44.199.230.1，答案是链路1。匹配的最长路径前缀为默认路径。
- 对于E，171.128.16.0，答案是链路2。此地址匹配两个前缀，默认路由和171.0.0.0/8。它与171.0.0.0/10不匹配，因为它在第9位不同。171.0.0.0/8是最长的前缀，因此路由器将在链路2上转发分组。





## 地址解析协议（Address Resolution Protocol）

**地址解析协议**，或称**ARP**，是网络层发现与它直接连接的网络地址相关的链路地址的机制。换句话说，它是一个设备如何获得问题的答案。"我有一个IP分组，它的下一跳是这个地址——我应该把它发送到哪个链路地址？"



### 地址层

![11/2]()

之所以需要ARP，是因为每个协议层都有自己的名称和地址。IP地址是一个网络层的地址：它描述了一个主机，一个网络层的唯一目的地。相比之下，一个链路地址描述了一个特定的网卡，一个发送和接收链路层帧的独特设备。例如，以太网有48位地址。每当你买了一块以太网卡，它就已经被预设了一个独特的以太网地址。因此，一个IP地址说的是“这个主机”，而一个以太网地址说的是“这个以太网卡”。



### 寻址问题

48位以太网地址通常写成以冒号为界的6个八位数，以十六进制书写，如源地址为0:13:72:4c:d9:6a，目的地址为9:9:9:9:9:9。

有一件事可能会让人困惑，虽然这些链路层和网络层的地址在协议层方面是完全解耦的，但在分配和管理方面，它们可能不是这样。例如，一台主机拥有多个IP地址是很常见的，每个接口都有一个。因为有了网络掩码的概念，它需要这样做。例如，请看这个假设的设置。网关在中间，有一个单一的IP地址：192.168.0.1。它有两个网卡，一个连接到目的地171.43.22.5，一个连接到源192.168.0.5。

192.168.0.1与171.43.22.5在同一个网络中所需要的网络掩码是128.0.0.0，或者说只有一个比特的网络掩码! 但不可能所有第一位为1的IP地址都与171.43.22.5在同一个网络中——例如，192.168.0.5需要通过网关到达。



### 寻址例子

![11/4]()

因此，我们经常看到这样的设置，即网关或路由器有多个接口，每个接口都有自己的链路层地址来识别该网卡，也有自己的网络层地址来识别该网卡所在网络中的主机。对于网关来说，左边的接口有IP地址192.168.0.1，而右边的接口有IP地址171.43.22.8。

链路层和网络层地址在逻辑上是解耦的，但在实践中是耦合的，这在某种程度上是一个历史遗留问题。当互联网开始时，有许多链路层，它希望能够在所有的链路层之上运行。这些链路层不会突然开始使用IP地址而不是他们自己的寻址方案。此外，事实证明，在很多情况下，拥有一个独立的链路层地址是非常有价值的。例如，当我在斯坦福大学的网络上注册一台计算机时，我注册它的链路层地址——即网卡的地址。



### 封装

![11/5]()

那么，这在实际中是什么意思呢？假设左边的节点A想向右边的节点B发送一个分组。它要生成一个源地址为192.168.0.5、目的地址为171.43.22.5的IP分组。

节点A检查目的地址是否在同一网络中。网络掩码255.255.255.0告诉它，目的地址在一个不同的网络中。这意味着节点A需要通过网关，即192.168.0.1发送分组。为此，它发送一个分组，其网络层目的地是171.43.22.5，但其链接层目的地是网关的链路层地址。所以这个分组的网络层目的地是171.43.22.5，链路层目的地是0:18:e7:f3:ce:1a。网络层源是192.168.0.5，链路层源是0:13:72:4c:d9:6a。

所以我们有一个从A到B的IP包，被封装在一个从A到左边网关接口的链路层帧内。当分组到达网关时，网关查找下一跳，确定它是节点B，并将IP分组放在通往B的链路层帧内。因此，从A到B的第二个IP分组是在从正确的网关接口到B的链路层内。



### 例子问题

![11/6]()

因此，在这里我们得到了ARP解决的问题。我的客户端知道它需要通过IP地址为192.168.0.1的网关发送一个分组。然而，要做到这一点，它需要有与192.168.0.1相关的链路层地址。它如何获得这个地址呢？我们需要以某种方式将第三层（网络层）地址映射到其相应的第二层（链路层）地址。我们用一个叫做ARP的协议来做这件事，也就是地址解析协议。



### 地址解析协议

ARP是一个简单的请求-回复协议。每个节点都保留了一个从其网络上的IP地址到链路层地址的映射的缓存。如果一个节点需要向它没有映射的IP地址发送一个分组，它就会发出一个请求。"谁有网络地址X？" 拥有该网络地址的节点回应说："我有网络地址X。" 响应包括链路层地址。收到响应后，请求者可以生成映射并发送分组。

为了使每个节点都能听到请求，一个节点向一个链路层广播地址发送请求。网络中的每个节点都会听到该分组。

此外，ARP的结构使其包含多余的数据。请求包含请求者的网络和链路层地址。这样，当节点听到请求时（因为它是广播的），它们可以在其缓存中插入或刷新映射。节点**只**对自己的请求作出回应。这意味着，假设没有人错误地生成分组，你可以为另一个节点生成映射的唯一方法是响应该节点发送的分组。因此，如果该节点崩溃或断开连接，则当所有缓存映射到期时，其状态将不可避免地离开网络。这使得ARP的调试和故障排除变得更加容易。

那么，这些动态发现的映射能持续多长时间？这取决于设备：例如，某些版本的Mac OSX将它们保留20分钟，而某些思科设备使用4小时的超时时间。我们的假设是，这些映射不会非常频繁地变化。



### ARP分组格式

![11/8]()

这就是ARP分组的实际样子。它有10个字段。硬件字段说明这个请求或响应是针对哪个链路层的。协议字段说明这个请求或响应是针对什么网络协议的。长度字段规定了链路层和网络层地址的字节数。操作码指定该分组是请求还是响应。

四个地址字段是用来请求和指定映射的。

记住，所有这些字段都是按网络顺序存储的，或者说是大端序。因此，如果我有一个15的操作码，它将在操作码字段中被存储为0x000f。

ARP的全部细节在IETF Request for Comments, RFC, 826中。我只讲一个简单的请求/响应交换。



### ARP请求

![11/9]()

因此，假设我们的客户端想通过其网关向更广泛的互联网发送一个分组。但它没有网关的以太网地址。

客户端将生成一个ARP请求包，其链路层源地址是其地址：68:a8:6d:05:82:22。目的链路层地址是广播地址：ff:ff:ff:ff:ff:ff:ff，都是1。

ARP请求将指定硬件是以太网，值为1，协议是IP，值为0x0800，硬件地址长度为6，协议长度为4。 操作码将是请求，其值为1。 ARP源硬件字段将是请求者的以太网地址，68:a8:6d:05:85:22。源协议字段是请求者的IP地址，192.168.0.5。目的硬件地址可以设置为任何内容——它是分组试图发现的内容。目标协议地址是客户端尝试为其查找映射的地址：192.168.0.1。客户端在以太网上发送这个帧。网络中的每个节点都会收到它，并刷新其链路地址68:a8:6d:05:85:22和网络地址192.168.0.5之间的映射，如果它没有映射，则插入一个映射。



### ARP响应

网关看到请求是针对其 IP 地址的，因此会生成回复。

与请求一样，ARP回复将指定硬件是以太网，值为1，协议是IP，值为0x0800，硬件地址长度为6，协议长度为4。 操作码将是回复，其值为2。

ARP源硬件字段将是回复者的以太网地址，0:18:e7:f3:ce:1a。源协议字段是：192.168.0.1。目标硬件地址是请求的源硬件地址：68:a8:6d:05:85:22。目标协议地址是请求的源协议地址：192.168.0.5。

你把响应发给哪个链路层地址是个开放性问题。最初的ARP规范说，回复者应该把它发送到请求者的链路层地址，所以是单播。然而，现在普遍的做法是广播，因为如果映射需要改变，这样做可以更积极地替换缓存条目。节点也可以发送所谓的无偿ARP分组，请求不存在的映射，以便在网络上宣传自己。

因此，我们已经看到，为了路由分组，人们需要能够将网络层地址映射到链路层地址。地址解析协议，即ARP，通过一个简单的请求——回复交换来提供这种服务。如果一个节点需要向或通过一个它没有链路层地址的IP地址发送分组，它可以通过ARP请求该地址。









## 互联网和IP回顾（The Internet and IP Recap）

![12/1]()

菲尔：

在本单元中，学习了一些关于互联网如何工作的基本知识。你学会了像Web浏览器和Skype这样的应用程序如何工作，一个应用程序如何使用互联网，以及互联网的基本结构。你了解了网络的一些基本架构原则。也许现在你已经知道我们中哪个是菲尔，哪个是尼克。

现在你已经完成了第一单元的学习，你应该非常熟悉这张互联网4层模型的图片。你现在知道互联网被分解成四个不同的层，这四个层是什么，以及它们是如何一起工作的。但比起它是如何工作的，你更希望了解它为什么这样工作，以及为什么分层在所有网络中都是一个好主意，而不仅仅是互联网。

你现在已经看到，互联网的工作方式是将数据分解成称为分组的小单元。当你请求一个网页时，你的电脑会向网络服务器发送一些分组。互联网决定这些小数据如何到达正确的目的地——以及网络服务器响应的、包含网页的分组如何正确地到达你的手中。

你已经学会了两个架构原则，即分层和分组，是如何在封装的架构原则中结合起来的。封装是如何让各层以简洁的方式使用分组，从而使每一层对分组的使用都独立于其他层。我们将在后面的单元中再谈一些架构原则。

尼克：

在本单元中，我们主要学习了四个主题。

1. 一个应用程序如何使用互联网。你了解到，大多数应用程序希望在两个或多个终端之间通过可靠的双向字节流进行通信。
2. 互联网的结构。你学会了什么是4层模型，以及每层的责任。你还了解到为什么我们每次在互联网上发送分组时都使用互联网协议或 "IP"，以及为什么我们称IP为互联网的 "细腰"。
 3. 互联网协议（IP）。由于IP是如此重要，我们花了几个视频来描述IP为我们做什么，以及它是如何工作的。到目前为止，我们把重点放在IPv4上，因为它是当今使用最广泛的IP版本。你将了解到IP地址，路由器如何查找IP地址等等。在本课程的后期，你将了解较新版本的IP，即IPv6。
4. 基本架构思想和原则。你已经学习了网络的三个基本原则，它们都与我们对互联网的理解非常相关。
   1. 第一个是分组交换，这是一种简单的方式，数据被分解成独立的信息包，根据包头的信息逐跳转发。
   2. 第二种是分层，我们已经提到过了。
   3. 第三是封装，即把在一层处理的分组放在下面的分组内的过程。这有助于明确区分数据在层次结构中每一层的处理方式。

菲尔：

你现在应该对互联网的基本结构和三个基本的架构理念有了很好的了解。你了解像你的网络浏览器这样的应用程序是如何工作的，以及互联网是如何在两台计算机之间传递分组的。你以前可能听说过TCP/IP这个术语：现在你知道什么是TCP，什么是IP，以及为什么它们是相关的。乍一看，这些可能看起来像琐碎的、低层次的细节。但事实证明，它们是互联网的基石。每年，互联网的新应用和新用途都在涌现。但所有这些都使用你正在学习的这些基本原则，而且几乎所有这些都使用TCP/IP。通过从这些基本原理入手，你将学习到即使在我们进入5G无线网络、Web 3.0和物联网时也会继续重要的知识。

这也是令人兴奋的部分原因。互联网和它能做的事情一直在扩大和变化。但有一些核心思想和原则在所有这些演变中是不变的。通过学习它们，你不仅知道今天的互联网和网络是如何工作的，而且很可能知道20年后它们将如何工作。